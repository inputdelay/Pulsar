<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="referrer" content="no-referrer">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1c1f24">
    <meta name="googlebot" content="index, follow, snippet">
    <meta name="robots" content="index, follow">
    <link rel="icon" href="Imgs/favicon.ico" type="image/x-icon">

    <title>Pulsar</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <!-- Your external CSS file - make sure to merge the styles below into this file -->
    <link rel="stylesheet" href="css/games-style.css">
    <!-- *** FIXED PATH *** Using CDN for particles.js -->
    <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4207227785539100"
         crossorigin="anonymous"></script>

    <style>
      /* --- Animation & Sleekness CSS (Merge into games-style.css) --- */
      /* Add this to your existing CSS file */

      /* Basic reset and font already in games-style.css, but ensure Lato is linked */
      /* * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Lato', sans-serif; scroll-behavior: smooth; } */

      body {
  overflow-x: hidden;
  position: relative;
  background: linear-gradient(135deg, #0f0063, #3c0081, #500072);
}

/* Dark overlay */
body::before {
  content: '';
  position: fixed; /* fixed to stay on viewport */
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #0f0063, #3c0081, #500072);
  z-index: -11;
  pointer-events: none;
  opacity: 1;  /* start fully visible */
  transition: opacity 0.3s ease-out;
}

      /* Particles.js Container */
      #particles-js {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -10;
      }

      @keyframes logoEntrance {
          from { opacity: 0; transform: translateX(-30px); }
          to { opacity: 1; transform: translateX(0); }
      }

      header h1 { /* Add styles if you decide to add a title next to the logo */
        font-size: 2rem;
        color: white; /* Or a gradient if desired */
        margin-left: 15px;
      }

      /* Navigation */
      nav ul {
        display: flex;
        list-style: none;
        gap: 15px; /* Consistent gap */
        align-items: center;
      }

      nav ul li a {
        text-decoration: none;
        font-size: 1rem; /* Consistent font size */
        color: rgba(255, 255, 255, 0.8); /* Softer white */
        padding: 8px 15px; /* Consistent padding */
        border-radius: 5px; /* Softer corners */
        transition: all 0.3s ease;
        position: relative; /* Needed for potential pseudo-elements */
      }

       nav ul li a.active {
           color: white;
           background: rgba(255, 255, 255, 0.15);
           text-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
       }


      nav ul li a:hover {
        color: white;
        background: rgba(255, 255, 255, 0.1); /* Subtle background on hover */
        text-shadow: 0 0 5px rgba(255, 255, 255, 0.5); /* Softer shadow on hover */
      }

      /* Discord/Special Buttons in Nav */
       nav ul li .discord-btn {
        display: inline-block;
        background: linear-gradient(90deg, #6d84d8, #546ab9); /* Consistent gradient */
        color: white;
        text-decoration: none;
        padding: 10px 20px; /* Adjusted padding */
        border-radius: 5px; /* Softer corners */
        font-weight: bold;
        box-shadow: 0 0 10px rgba(114, 137, 218, 0.4); /* Discord color shadow */
        transition: all 0.3s ease;
      }

      /* Main Content Area - Needs top padding to not be hidden by fixed header */
      .hub-container {
          padding: 100px 20px 20px 20px; /* Add top padding equal to or more than header height */
          position: relative; /* Needed for particles z-index */
          z-index: 1; /* Ensure content is above particles */
      }

      /* Search and Controls section animation */
      .hub-controls {
         /* Your existing styles */
         opacity: 0;
         transform: translateY(20px);
         animation: controlsEntrance 0.6s ease-out forwards 0.7s; /* Animation with delay */
         margin-bottom: 30px; /* Space below search */
      }

      @keyframes controlsEntrance {
          from { opacity: 0; transform: translateY(20px); }
          to { opacity: 1; transform: translateY(0); }
      }

      /* Category Wrapper entrance animation (optional, or stagger categories/buttons) */
      .categories-wrapper {
          /* Your existing styles */
          opacity: 0;
          transform: translateY(20px);
          animation: categoriesEntrance 0.6s ease-out forwards 0.9s; /* Animation with delay */
      }

      @keyframes categoriesEntrance {
           from { opacity: 0; transform: translateY(20px); }
           to { opacity: 1; transform: translateY(0); }
      }


       /* You might want to add entrance animations for category headers or individual buttons */
       /* Example for category headers: */
       .game-category .category-header h6 {
           opacity: 0;
           transform: translateX(-20px);
           animation: categoryHeaderEntrance 0.5s ease-out forwards;
           /* Delay could be staggered per category or depend on the wrapper anim */
           /* For simplicity, let's just give it a base delay */
           animation-delay: 1.2s;
       }
        @keyframes categoryHeaderEntrance {
           from { opacity: 0; transform: translateX(-20px); }
           to { opacity: 1; transform: translateX(0); }
        }


       /* Example for individual game buttons - this would require a lot of nth-child or JS staggering */
       /* .btn {
           opacity: 0;
           transform: translateY(10px);
           animation: buttonEntrance 0.4s ease-out forwards;
           animation-delay: calc(1.3s + var(--button-index) * 0.05s); // Example using CSS variable and JS
       } */
       /* @keyframes buttonEntrance {
           from { opacity: 0; transform: translateY(10px); }
           to { opacity: 1; transform: translateY(0); }
       } */


      /* No Results Message animation */
      #noResultsMessage {
          /* Your existing styles */
          opacity: 0; /* Start hidden */
          transform: translateY(20px);
          animation: noResultsEntrance 0.5s ease-out forwards; /* Animation */
          animation-delay: 1.5s; /* Delay it after other elements appear */
      }

      @keyframes noResultsEntrance {
          from { opacity: 0; transform: translateY(20px); }
          to { opacity: 1; transform: translateY(0); }
      }

      /* --- FIX FOR HEADER/BUTTON CONTAINER LAYOUT --- */
      /* Add these rules to your games-style.css */
      .game-category {
          display: flex; /* Make the section a flex container */
          flex-direction: column; /* Stack the children (.category-header and .btn-container) vertically */
          margin-bottom: 30px; /* Add spacing between categories */
      }

      .category-header {
          display: flex; /* Make the header div a flex container */
          justify-content: space-between; /* Space out the h6 and scroll arrows */
          align-items: center; /* Vertically align the h6 and scroll arrows */
          margin-bottom: 15px; /* Add space between the header and the button container */
      }
      /* --- END FIX --- */


      /* Responsive adjustments */
      @media (max-width: 768px) {
        header {
          flex-direction: column;
          padding: 10px 20px;
          align-items: flex-start;
        }
        header img.header-logo {
            height: 40px;
            margin-bottom: 10px;
            animation-delay: 0.1s !important;
        }
         header { animation-delay: 0s !important; } /* Start header anim earlier on mobile */

         nav ul li:nth-child(1) { animation-delay: 0.4s !important; } /* Adjust nav delays */
         nav ul li:nth-child(2) { animation-delay: 0.45s !important; }
         nav ul li:nth-child(3) { animation-delay: 0.5s !important; }
         nav ul li:nth-child(4) { animation-delay: 0.55s !important; }
         nav ul li:nth-child(5) { animation-delay: 0.6s !important; }
         nav ul li:nth-child(6) { animation-delay: 0.65s !important; }


        header h1 {
          font-size: 1.6rem;
          margin-left: 0;
        }
        nav ul {
          margin-top: 10px;
          gap: 8px;
          flex-wrap: wrap;
          justify-content: center;
        }

        nav ul li a,
        nav ul li .discord-btn {
          font-size: 0.8rem;
          padding: 6px 12px;
        }

        .hub-container {
             padding-top: 100px; /* Maintain padding for header */
             padding-left: 10px;
             padding-right: 10px;
        }

         .hub-controls {
             animation-delay: 0.8s !important;
         }

        .categories-wrapper {
            animation-delay: 1s !important;
        }
         .game-category .category-header h6 {
            animation-delay: 1.3s !important;
         }

         #noResultsMessage {
             animation-delay: 1.6s !important;
         }
      }
/* Arrow animations */
/* Arrow animations */
.scroll-arrow {
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 1;
    transform: scale(1) translateZ(0); /* Add translateZ for GPU acceleration */
    transition: opacity 0.3s ease, transform 0.3s ease;
    pointer-events: auto;
    cursor: pointer;
    width: 40px;
    height: 40px;
    background: rgba(0, 0, 0, 0.5);
    color: white;
    border-radius: 50%;
    will-change: opacity, transform; /* Optimize for animation */
}

.scroll-arrow.hidden {
    opacity: 0;
    transform: scale(0.8) translateZ(0);
    pointer-events: none;
}

.scroll-arrow:hover {
    transform: scale(1.1) translateZ(0);
    background: rgba(0, 0, 0, 0.7);
}

.scroll-arrow:active {
    transform: scale(0.95) translateZ(0);
    transition: transform 0.1s ease;
}

@keyframes arrowPulse {
    0% { transform: scale(1) translateZ(0); }
    50% { transform: scale(1.15) translateZ(0); }
    100% { transform: scale(1) translateZ(0); }
}

.scroll-arrow.show-pulse {
    animation: arrowPulse 0.4s ease;
}

/* Container scrolling */
.btn-container, .favorite-container, .btn-container-grid {
    display: flex;
    overflow-x: auto;
    scroll-behavior: auto; /* Disable native smooth scrolling for custom animation */
    will-change: scroll-position; /* Optimize for scrolling */
    transform: translateZ(0); /* Force GPU rendering */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE/Edge */
}

.btn-container::-webkit-scrollbar, 
.favorite-container::-webkit-scrollbar, 
.btn-container-grid::-webkit-scrollbar {
    display: none; /* Chrome/Safari */
}

.btn {
    flex: 0 0 auto;
    transform: translateZ(0); /* GPU acceleration for buttons */
    /* Avoid heavy styles like box-shadow or complex gradients */
}
      /* --- END Animation & Sleekness CSS --- */

    </style>
</head>
<body>
    <!-- Particles.js Background -->
    <div id="particles-js"></div>

    <!-- Main Game Hub Content Area -->
    <main class="hub-container">

        <!-- Search and Controls -->
        <section class="hub-controls">
            <div class="search-wrapper" id="searchWrapper">
                <input type="text" id="myInput" placeholder="Search for games...">
                <button class="search-icon-btn" aria-label="Search">
                   <i class="fa fa-search"></i>
                </button>
            </div>
            <a href="games.html" style="text-decoration: none;"class="toggle-categories-btn">View All Games</a>
        </section>

        <!-- Container for Categories -->
        <div class="categories-wrapper" id="categoriesWrapper">

 <!-- All Games Section -->
 <section class="game-category all-games-section">
    <div class="category-header">
    <h6 id="category-title"><i class="fas fa-star"></i> All Games</h6>
    </div>
     <div id="btnnn-container" class="btnnn-container"></div>
    </section>

    <script>
      const params = new URLSearchParams(window.location.search);
      const category = params.get('category'); // e.g. "puzzle"
    
      const container = document.getElementById('btnnn-container');
      const categoryTitle = document.getElementById('category-title');
    
      let categoryNameFormatted;
    
      if (category === 'mini') {
        categoryNameFormatted = 'All Minigames';
      } else if (category === 'all') {
        categoryNameFormatted = 'All Games';
      } else if (category) {
        categoryNameFormatted = `All ${category.charAt(0).toUpperCase() + category.slice(1)} Games`;
      } else {
        categoryNameFormatted = 'All Games';
      }
    
      categoryTitle.innerHTML = `<i class="fas fa-star"></i> ${categoryNameFormatted}`;
    
      fetch('games.html').then(res => res.text()).then(htmlText => {
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlText, 'text/html');
    
        const categoryDiv = doc.getElementById(`${category}-category`);
        if (!categoryDiv) {
          container.textContent = 'Category not found.';
          return;
        }
    
        container.textContent = ''; // clear loading text
        categoryDiv.querySelectorAll('button').forEach(btn => {
          container.appendChild(btn.cloneNode(true));
        });
      }).catch(() => {
        container.textContent = 'Failed to load games.';
      });
    </script>

        </div> <!-- Close categories-wrapper -->

        <!-- Message for no search results -->
        <p id="noResultsMessage" style="display: none; text-align: center; margin-top: 30px; font-size: 1.3em; color: #ccc;">
            No games found matching your search.
        </p>

    </main> <!-- Close main.hub-container -->

     <!-- --- Scripts --- -->

     <script>
        // --- Utility: Debounce Function ---
        function debounce(func, wait, immediate) {
          var timeout;
          return function() {
            var context = this, args = arguments;
            var later = function() {
              timeout = null;
              if (!immediate) func.apply(context, args);
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func.apply(context, args);
          };
        }
        </script>
        
        <script>
        // --- Utility: Get Button Name ---
        function getButtonName(button) {
           const spanText = button.querySelector('.game-info-bar .game-name')?.textContent.trim();
           if (spanText) return spanText;
        
           const imgAlt = button.querySelector('.imgg')?.alt;
           if (imgAlt) return imgAlt;
        
           let name = "";
           button.childNodes.forEach(node => {
             if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== "") {
               name = node.textContent.trim();
             }
           });
           if (name) return name;
        
           const path = button.getAttribute('data-path');
           if (path) {
               let pathName = path.split('/').pop().split('.')[0].replace(/[-_]/g, ' ');
               return pathName.replace(/\b\w/g, l => l.toUpperCase());
           }
        
           return 'Unknown Game';
        }
        </script>
        
        <script>
        // --- Save and Remove Favorites ---
        function saveFavorite(button) {
            const gameId = button.dataset.gameId;
            let favorites = JSON.parse(localStorage.getItem('favoriteGames')) || [];
        
            if (!favorites.includes(gameId)) {
                favorites.push(gameId);
                localStorage.setItem('favoriteGames', JSON.stringify(favorites));
            }
        }
        
        function removeFavorite(button) {
            const gameId = button.dataset.gameId;
            let favorites = JSON.parse(localStorage.getItem('favoriteGames')) || [];
        
            favorites = favorites.filter(id => id !== gameId);
            localStorage.setItem('favoriteGames', JSON.stringify(favorites));
        }
        </script>
        
        <script>
        // --- Load Favorites on Page Load ---
        function loadFavorites() {
            const favoritesContainer = document.querySelector("#favoritesSection .favorite-container");
            const favoritesSection = document.getElementById("favoritesSection");
            const savedFavorites = JSON.parse(localStorage.getItem('favoriteGames')) || [];
        
            if (savedFavorites.length === 0) {
                favoritesSection.style.display = "none";
                return;
            }
        
            fetch('games.html').then(res => res.text()).then(htmlText => {
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlText, 'text/html');
        
                savedFavorites.forEach(gameId => {
                    const button = doc.querySelector(`button[data-game-id="${gameId}"]`);
                    if (button) {
                        const clonedButton = button.cloneNode(true);
        
                        const heartIcon = clonedButton.querySelector('.heart-icon');
                        if (heartIcon) {
                            heartIcon.classList.add('hearted');
                            heartIcon.addEventListener('click', event => {
                                event.stopPropagation();
                                removeFavorite(clonedButton);
                                clonedButton.remove();
                                if (favoritesContainer.children.length === 0) {
                                    favoritesSection.style.display = "none";
                                }
                            });
                        }
        
                        favoritesContainer.appendChild(clonedButton);
                    }
                });
        
                favoritesSection.style.display = "";
            }).catch(() => {
                favoritesContainer.innerHTML = 'Failed to load favorites.';
            });
        }
        
        document.addEventListener("DOMContentLoaded", loadFavorites);
        </script>
        
<script>
        // Define functions needed by event listeners

        // --- Scroll Arrow Logic Definition ---
        function setupScrollArrows(category) {
    const btnContainer = category.querySelector('.btn-container, .favorite-container, .btn-container-grid');
    const leftArrow = category.querySelector('.scroll-arrow.left-arrow');
    const rightArrow = category.querySelector('.scroll-arrow.right-arrow');

    if (!btnContainer || !leftArrow || !rightArrow) {
        return;
    }

    let scrollAmount;
    const updateScrollAmount = () => {
        // Calculate scroll amount based on visible buttons or container width
        const visibleButtons = Array.from(btnContainer.querySelectorAll('.btn'))
            .filter(btn => window.getComputedStyle(btn).display !== 'none');
        if (visibleButtons.length > 0) {
            const buttonWidth = visibleButtons[0].offsetWidth; // Assume uniform width
            scrollAmount = Math.max(buttonWidth * 3, 150); // Scroll ~2 buttons, min 150px
        } else {
            scrollAmount = btnContainer.clientWidth / 2; // Fallback: half container width
        }
    };

    // Initial calculation
    updateScrollAmount();

    function updateArrowVisibility() {
        if (!category.offsetParent || !btnContainer.offsetParent || 
            window.getComputedStyle(btnContainer).display === 'none' || 
            window.getComputedStyle(category).display === 'none') {
            leftArrow.classList.add('hidden');
            rightArrow.classList.add('hidden');
            return;
        }

        const visibleButtons = Array.from(btnContainer.querySelectorAll('.btn'))
            .filter(btn => window.getComputedStyle(btn).display !== 'none');
        if (visibleButtons.length === 0) {
            leftArrow.classList.add('hidden');
            rightArrow.classList.add('hidden');
            return;
        }

        const tolerance = 5;
        const maxScrollLeft = btnContainer.scrollWidth - btnContainer.clientWidth;
        const canScroll = btnContainer.scrollWidth > btnContainer.clientWidth + tolerance;

        // Update left arrow
        if (canScroll && btnContainer.scrollLeft > tolerance) {
            leftArrow.classList.remove('hidden');
            if (!leftArrow._wasVisible) {
                leftArrow.classList.add('show-pulse');
                setTimeout(() => leftArrow.classList.remove('show-pulse'), 400);
            }
            leftArrow._wasVisible = true;
        } else {
            leftArrow.classList.add('hidden');
            leftArrow._wasVisible = false;
        }

        // Update right arrow
        if (canScroll && btnContainer.scrollLeft < maxScrollLeft - tolerance) {
            rightArrow.classList.remove('hidden');
            if (!rightArrow._wasVisible) {
                rightArrow.classList.add('show-pulse');
                setTimeout(() => rightArrow.classList.remove('show-pulse'), 400);
            }
            rightArrow._wasVisible = true;
        } else {
            rightArrow.classList.add('hidden');
            rightArrow._wasVisible = false;
        }
    }

    const debouncedUpdateArrows = debounce(updateArrowVisibility, 50);
    category._updateArrowVisibility = debouncedUpdateArrows;

    btnContainer.addEventListener('scroll', debouncedUpdateArrows);

    const mutationObserver = new MutationObserver(debouncedUpdateArrows);
    mutationObserver.observe(btnContainer, { childList: true, attributes: true, subtree: true });

    const resizeObserver = new ResizeObserver(() => {
        updateScrollAmount();
        debouncedUpdateArrows();
    });
    resizeObserver.observe(btnContainer);
    resizeObserver.observe(category);

    // Easing function: ease-in-out quadratic
    const easeInOutQuad = t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

    // Custom scroll animation with requestAnimationFrame
    let isAnimating = false;
    const animateScroll = (direction, duration = 400) => {
        if (isAnimating) return;
        isAnimating = true;

        const start = btnContainer.scrollLeft;
        const target = start + direction * scrollAmount;
        const startTime = performance.now();

        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1); // Clamp to 1
            const easedProgress = easeInOutQuad(progress);
            btnContainer.scrollLeft = start + (target - start) * easedProgress;

            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                isAnimating = false;
            }
        };

        requestAnimationFrame(animate);
    };

    const scrollStep = (direction) => {
        if (isNaN(scrollAmount) || scrollAmount <= 0) return;
        animateScroll(direction, 400); // 400ms duration for smoother feel
    };

    // Remove existing listeners if present
    if (category._scrollStepListeners) {
        leftArrow.removeEventListener('click', category._scrollStepListeners.left);
        rightArrow.removeEventListener('click', category._scrollStepListeners.right);
        leftArrow.removeEventListener('mousedown', category._scrollStepListeners.leftHoldStart);
        leftArrow.removeEventListener('mouseup', category._scrollStepListeners.leftHoldStop);
        leftArrow.removeEventListener('mouseleave', category._scrollStepListeners.leftHoldStop);
        leftArrow.removeEventListener('touchstart', category._scrollStepListeners.leftHoldStartTouch);
        leftArrow.removeEventListener('touchend', category._scrollStepListeners.leftHoldStop);
        leftArrow.removeEventListener('touchcancel', category._scrollStepListeners.leftHoldStop);

        rightArrow.removeEventListener('mousedown', category._scrollStepListeners.rightHoldStart);
        rightArrow.removeEventListener('mouseup', category._scrollStepListeners.rightHoldStop);
        rightArrow.removeEventListener('mouseleave', category._scrollStepListeners.rightHoldStop);
        rightArrow.removeEventListener('touchstart', category._scrollStepListeners.rightHoldStartTouch);
        rightArrow.removeEventListener('touchend', category._scrollStepListeners.rightHoldStop);
        rightArrow.removeEventListener('touchcancel', category._scrollStepListeners.rightHoldStop);
    }

    const leftClickListener = () => scrollStep(-1);
    const rightClickListener = () => scrollStep(1);

    leftArrow.addEventListener('click', leftClickListener);
    rightArrow.addEventListener('click', rightClickListener);

    let scrollHoldInterval = null;
    const startHoldScrolling = (direction) => {
        stopHoldScrolling();
        if (!isAnimating) {
            scrollStep(direction); // Immediate scroll
            scrollHoldInterval = setInterval(() => {
                if (!isAnimating) scrollStep(direction);
            }, 450); // Slightly longer than animation duration (400ms)
        }
    };
    const stopHoldScrolling = () => {
        clearInterval(scrollHoldInterval);
        scrollHoldInterval = null;
    };

    const leftHoldStart = () => startHoldScrolling(-1);
    const leftHoldStop = stopHoldScrolling;
    const leftHoldStartTouch = (e) => { e.preventDefault(); startHoldScrolling(-1); };

    const rightHoldStart = () => startHoldScrolling(1);
    const rightHoldStop = stopHoldScrolling;
    const rightHoldStartTouch = (e) => { e.preventDefault(); startHoldScrolling(1); };

    leftArrow.addEventListener('mousedown', leftHoldStart);
    leftArrow.addEventListener('mouseup', leftHoldStop);
    leftArrow.addEventListener('mouseleave', leftHoldStop);
    leftArrow.addEventListener('touchstart', leftHoldStartTouch, { passive: false });
    leftArrow.addEventListener('touchend', leftHoldStop);
    leftArrow.addEventListener('touchcancel', leftHoldStop);

    rightArrow.addEventListener('mousedown', rightHoldStart);
    rightArrow.addEventListener('mouseup', rightHoldStop);
    rightArrow.addEventListener('mouseleave', rightHoldStop);
    rightArrow.addEventListener('touchstart', rightHoldStartTouch, { passive: false });
    rightArrow.addEventListener('touchend', rightHoldStop);
    rightArrow.addEventListener('touchcancel', rightHoldStop);

    category._scrollStepListeners = {
        left: leftClickListener, right: rightClickListener,
        leftHoldStart: leftHoldStart, leftHoldStop: leftHoldStop, leftHoldStartTouch: leftHoldStartTouch,
        rightHoldStart: rightHoldStart, rightHoldStop: rightHoldStop, rightHoldStartTouch: rightHoldStartTouch
    };

    // Initial visibility update
    updateArrowVisibility();
}

// Debounce function (include if not using Lodash)
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}
        // --- END Scroll Arrow Logic Definition ---


        // --- Search Filter Logic Definition ---
        function filterGames() {
          const input = document.getElementById('myInput');
          const filter = input.value.toUpperCase().trim();
          const categoriesWrapper = document.getElementById('categoriesWrapper');
          // Select all categories
          const categories = categoriesWrapper?.querySelectorAll('.game-category');
          const noResultsMessage = document.getElementById('noResultsMessage');
          let hasVisibleGames = false; // Tracks if *any* game button is visible across all categories

          // console.log(`--- Filtering for: "${filter}" ---`); // Debug filter term

          categories?.forEach(category => {
            const buttons = category.querySelectorAll('.btn');
            let categoryHasVisibleButton = false; // Track if this specific category should be visible

            buttons.forEach(button => {
              const gameName = getButtonName(button); // Use the robust helper
              const buttonMatches = gameName.toUpperCase().includes(filter);

              if (buttonMatches) {
                if (button.classList.contains('hidden')) {
                    // console.log(` ✅ Showing: ${gameName} in ${category.querySelector('h6')?.textContent}`); // Debug show
                    button.classList.remove('hidden');
                }
                hasVisibleGames = true; // At least one game is visible overall
                categoryHasVisibleButton = true; // This category has at least one visible game
              } else {
                 if (!button.classList.contains('hidden')) {
                   // console.log(` ❌ Hiding: ${gameName} in ${category.querySelector('h6')?.textContent}`); // Debug hide
                    button.classList.add('hidden');
                 }
              }
            });

            // Decide if the category section itself should be visible.
            // If the filter is empty, all categories should show.
            // If the filter is not empty, the category should show *only if* it contains visible buttons.
            if (filter === '') {
                category.style.display = ''; // Show all categories when filter is empty
            } else {
                 // When filtering, only show categories that have at least one matching game
                 category.style.display = categoryHasVisibleButton ? '' : 'none';
            }


            // Update category arrows (always, as content/visibility changes)
            // This needs to happen regardless of whether the category is hidden or shown,
            // because hiding/showing affects layout, and the arrows might need to update
            // based on the *remaining* visible buttons within a scrolling container.
             const updateFunc = category._updateArrowVisibility;
             if (typeof updateFunc === 'function') {
                // Use a small timeout to allow display property changes to render first
                setTimeout(updateFunc, 10);
             }
          });

          // Handle "No Results" message
          if (noResultsMessage) {
            // Only show the message if the filter is NOT empty AND no games were marked visible *across all categories*
            noResultsMessage.style.display = (filter !== '' && !hasVisibleGames) ? 'block' : 'none';
          }

          // Note: The favoriting logic's updateFavoritesSectionVisibility already correctly
          // toggles the favorites section display based on whether it *has* any favorited items *at all*,
          // not based on whether those favorites are visible *after search*.
          // The search filter logic above ensures the individual buttons *within* the favorites section
          // are correctly hidden/shown based on the search term. This seems like the desired behavior.
        }
        // --- END Search Filter Logic Definition ---


        // --- Game Launch Logic Definition ---
        // This function is no longer needed for initial buttons due to event delegation.
        // It *is* still used by the favoriting script when it clones buttons.
        function addGameLaunchListener(button) {
          // console.log("addGameLaunchListener called for:", getButtonName(button)); // DEBUG
          // No need to add listener here, delegation handles it.
          // The favoriting script might call this, but it's safer to rely on delegation.
          // We'll leave this stub here in case the favoriting script is strictly dependent on it,
          // but the actual game launch will be handled by the delegated listener.
          // We *could* add a check like:
          // if (button.closest('#favoritesSection') && !button._hasGameLaunchListener) { ... add listener ... button._hasGameLaunchListener = true;}
          // But relying solely on delegation is more robust.

          // Removing the actual event listener attachment from here.
          // The core logic for game launch is now ONLY in the delegated listener.
          // The favoriting script just needs the button element cloned correctly with data-path and game-name span/img.
        }
        // --- END Game Launch Logic Definition ---

      </script>

      <!-- Favoriting Logic (Self-contained in IIFE) -->
      <script>
          // --- Favoriting Logic ---
          (() => { // Using an IIFE
              let favoriteContainer = null;
              let favoritesSection = null;

              function updateFavoritesSectionVisibility() {
                   if (!favoriteContainer || !favoritesSection) return;
                   // The section should be visible if it has ANY child buttons, regardless of their hidden state from search
                   const hasAnyFavorites = favoriteContainer.children.length > 0;
                   favoritesSection.style.display = hasAnyFavorites ? '' : 'none';

                   // Always trigger arrow update if the section *could* be visible
                   if (hasAnyFavorites) {
                       const updateFunc = favoritesSection._updateArrowVisibility; // Assumes setupScrollArrows stored it
                       if (typeof updateFunc === 'function') setTimeout(updateFunc, 10); // Delay slightly
                   }
              }

              // Handles the click event on the heart icon itself
              function handleHeartIconClick(event) {
                  event.stopPropagation(); // Prevent the button click event from firing
                  // console.log("Heart icon clicked!", event.target); // DEBUG
                  const heartIcon = event.currentTarget;
                  const button = heartIcon.closest(".btn");
                  if (!button) return;

                  toggleFavoriteState(button); // Pass the button element
              }

              // Toggles the hearted class and updates localStorage/Favorites section
               function toggleFavoriteState(button) {
                   const heartIcon = button.querySelector('.heart-icon');
                   if (!heartIcon) return;

                   let gameId = button.dataset.gameId;
                   // If gameId is missing, generate one from the path for robustness (shouldn't happen with fixed HTML)
                   if (!gameId) {
                       const gamePath = button.getAttribute("data-path");
                       gameId = gamePath ? `fav-${gamePath.replace(/[^a-zA-Z0-9]+/g, '-')}` : `fav-unknown-${Math.random().toString(16).slice(2)}`;
                       button.dataset.gameId = gameId; // Add the generated ID to the button
                       console.warn(`Generated gameId for button on click: ${gameId}`); // Debug generated ID
                   }

                   const isCurrentlyHearted = heartIcon.classList.contains("hearted");
                   const allMatchingButtons = document.querySelectorAll(`.btn[data-game-id="${gameId}"]`); // Select all buttons with this gameId

                   if (isCurrentlyHearted) {
                       // Remove 'hearted' class from ALL buttons with this gameId
                       allMatchingButtons.forEach(btn => btn.querySelector('.heart-icon')?.classList.remove("hearted"));
                       localStorage.setItem(`heartState-${gameId}`, "false");
                       removeFromFavorites(gameId); // Remove from the favorites section
                   } else {
                       // Was not liked, liking
                       // Add 'hearted' class to ALL buttons with this gameId
                       allMatchingButtons.forEach(btn => btn.querySelector('.heart-icon')?.classList.add("hearted"));
                       localStorage.setItem(`heartState-${gameId}`, "true");
                       // Find the original button (not the one already in favorites section) to clone
                       // We need to be careful to clone one from a non-favorite section to avoid cloning the clone.
                       const originalButton = document.querySelector(`.categories-wrapper .game-category:not(#favoritesSection) .btn[data-game-id="${gameId}"]`);
                       if (originalButton) {
                           addToFavorites(originalButton); // Add to the favorites section
                       } else {
                            // This case might happen if the page reloaded and the favorite button already exists
                            // in the favorites section, and you click its heart icon.
                            // The state is already handled above (hearted class is added).
                            // Just ensure visibility and arrows are correct.
                           // console.warn("Could not find original button to clone for favorite:", gameId, "Assuming it's already added."); // DEBUG
                           updateFavoritesSectionVisibility(); // Just ensure visibility and arrows are correct
                       }
                   }
               }

               function addToFavorites(originalButton) {
                   if (!favoriteContainer) return;
                   const gameId = originalButton.dataset.gameId;
                   // Check if the favorite button already exists in the favorites container
                   const existingFavorite = favoriteContainer.querySelector(`.btn[data-game-id="${gameId}"]`);

                   if (!existingFavorite) {
                       // Clone the button - IMPORTANT: Deep clone to get heart icon, spans etc.
                       const clonedButton = originalButton.cloneNode(true);
                       // Ensure it has the hearted class (should be already set by toggleFavoriteState)
                       const clonedHeartIcon = clonedButton.querySelector('.heart-icon');
                       if (clonedHeartIcon) {
                           clonedHeartIcon.classList.add('hearted'); // Ensure it's hearted
                            // Remove any old listeners on the cloned icon (just in case)
                            // Re-add the heart click listener to the cloned heart icon
                            // We need to be careful not to add duplicates if addToFavorites is called multiple times on the same item.
                            // A simple flag or checking attached listeners would be better, but for now, let's ensure handleHeartIconClick can handle multiple calls or rely on the existingFavorite check.
                           clonedHeartIcon.removeEventListener('click', handleHeartIconClick); // Remove potential old listener
                           clonedHeartIcon.addEventListener('click', handleHeartIconClick); // Add new one
                       }
                       // The delegated listener on the main container will handle the game launch click for the clone.

                       favoriteContainer.appendChild(clonedButton);
                   } else {
                       // If it already exists, just ensure the hearted class is there (should be already)
                       existingFavorite.querySelector('.heart-icon')?.classList.add('hearted');
                       // console.warn(`Favorite button for ${gameId} already exists in favorites container.`); // Debug case
                       // Ensure its heart icon listener is attached (safer to check and add if missing)
                       const existingHeartIcon = existingFavorite.querySelector('.heart-icon');
                       if (existingHeartIcon && !existingHeartIcon._hasHeartListener) { // Use a simple flag
                            existingHeartIcon.addEventListener('click', handleHeartIconClick);
                            existingHeartIcon._hasHeartListener = true; // Set flag
                       }
                   }

                   updateFavoritesSectionVisibility(); // Update visibility and arrows of the favorites section
               }

               function removeFromFavorites(gameId) {
                   const favoritedItem = favoriteContainer?.querySelector(`.btn[data-game-id="${gameId}"]`);
                   if (favoritedItem) {
                       // Remove the button from the favorites container
                       favoriteContainer.removeChild(favoritedItem);
                   }
                   updateFavoritesSectionVisibility(); // Update visibility and arrows of the favorites section
               }


              // This runs when the DOM is ready for *this script block*
              document.addEventListener("DOMContentLoaded", function() {
                   favoriteContainer = document.querySelector("#favoritesSection .favorite-container");
                   favoritesSection = document.getElementById('favoritesSection');
                   if (!favoriteContainer || !favoritesSection) {
                       console.error("Favorites container or section not found."); // Debug missing elements
                       return;
                   }

                   // Pass 1: Assign IDs, Attach Heart Listeners, and Read Initial State
                   // Iterate through ALL buttons that have a data-path to ensure they get gameIds and heart listeners
                   document.querySelectorAll(".categories-wrapper .btn[data-path]").forEach(button => {
                      const heartIcon = button.querySelector(".heart-icon");
                      if (!heartIcon) {
                          //console.warn("Button missing heart icon:", button); // Debug missing heart
                          return; // Skip buttons without heart icons
                      }

                      // Generate gameId if not already present (added this in HTML now, but keep as fallback)
                      let gameId = button.dataset.gameId;
                       if (!gameId) {
                           const gamePath = button.getAttribute("data-path");
                           // Sanitize path to create a valid ID
                           gameId = gamePath ? `fav-${gamePath.replace(/[^a-zA-Z0-9]+/g, '-')}` : `fav-unknown-${Math.random().toString(16).slice(2)}`;
                           button.dataset.gameId = gameId; // Add the generated ID to the button element
                           //console.warn(`Generated gameId for button on load: ${gameId}`); // Debug generated ID
                       }

                      // Attach the heart click listener ONCE
                      // Check if listener is already attached (using a flag)
                      if (!heartIcon._hasHeartListener) {
                           heartIcon.addEventListener('click', handleHeartIconClick);
                           heartIcon._hasHeartListener = true; // Set flag
                      }


                      // Check localStorage for initial state and set 'hearted' class
                      const isHearted = localStorage.getItem(`heartState-${gameId}`) === "true"; // Use the gameId as key
                      if (isHearted) {
                          heartIcon.classList.add("hearted");
                      } else {
                          heartIcon.classList.remove("hearted"); // Ensure it's not hearted if state is false/missing
                      }
                   });

                   // Pass 2: Populate Favorites Section based on localStorage state
                   // Iterate through ALL buttons again, this time populating the favorites section
                   document.querySelectorAll(".categories-wrapper .game-category:not(#favoritesSection) .btn[data-game-id]").forEach(button => { // Only process buttons NOT already in favorites
                       const gameId = button.dataset.gameId;
                       const isHearted = localStorage.getItem(`heartState-${gameId}`) === "true"; // Use the gameId as key
                       // If hearted, add it to the favorites section
                       if (isHearted) {
                           addToFavorites(button); // addToFavorites handles cloning and listener for heart icon
                       }
                   });

                   // Initial update of favorites section visibility
                   updateFavoritesSectionVisibility();
                   // console.log("Favoriting logic initialized."); // Debug init complete
              });
          })(); // Immediately invoke
          // --- END Favoriting Logic ---
      </script>

      <!-- Category Toggle Logic (Self-contained in IIFE) -->
      <script>
        // --- Category Toggle Logic ---
        (() => {
            document.addEventListener('DOMContentLoaded', () => { // Wait for elements
                  const toggleBtn = document.getElementById('Toggle'); // Assuming there's a button with id="Toggle"
                  const categoriesWrapper = document.getElementById('categoriesWrapper');
                  if(!toggleBtn || !categoriesWrapper) {
                      //console.warn("Toggle button or categories wrapper not found."); // Debug missing elements
                      return;
                  }

                  toggleBtn.addEventListener('click', () => {
                      const isHidden = window.getComputedStyle(categoriesWrapper).display === 'none';
                      if (isHidden) {
                          categoriesWrapper.style.display = ''; // Show wrapper
                          toggleBtn.textContent = 'Hide Categories';
                          toggleBtn.setAttribute('aria-expanded', 'true');
                          // Trigger arrow updates for all visible categories after showing
                          document.querySelectorAll('.game-category').forEach(category => {
                              if (window.getComputedStyle(category).display !== 'none') { // Only update visible ones
                                  const updateFunc = category._updateArrowVisibility;
                                  if (typeof updateFunc === 'function') setTimeout(updateFunc, 10);
                              }
                          });
                      } else {
                          categoriesWrapper.style.display = 'none'; // Hide wrapper
                          toggleBtn.textContent = 'Show Categories';
                          toggleBtn.setAttribute('aria-expanded', 'false');
                      }
                  });
                  // Set initial state based on CSS display
                  toggleBtn.setAttribute('aria-expanded', window.getComputedStyle(categoriesWrapper).display !== 'none');
                  // console.log("Category toggle logic initialized."); // Debug init complete
            });
        })();
        // --- END Category Toggle Logic ---
      </script>

      <!-- Main Initializer (Runs on DOMContentLoaded) -->
      <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log("Main Initializer: DOM Loaded. Initializing...");

             // NOTE: Favoriting logic runs *within* its own DOMContentLoaded listener
             // and populates the favorites section *before* this script continues
             // beyond its initial setup. This is good.

            // 1. Setup Scroll Arrows for ALL categories
            // This needs to run *after* the DOM is fully loaded and potentially populated by
            // other scripts like the favoriting logic. The IIFE ensures the favoriting
            // population happens during DOMContentLoaded.
            try {
                console.log("Main Initializer: Setting up scroll arrows for all categories...");
                 // Select all elements with class 'game-category' and run setupScrollArrows on them.
                 // This will now target both the favorites section (with its favorite-container)
                 // and the All Apps section (with its btn-container-grid).
                document.querySelectorAll('.game-category').forEach(setupScrollArrows);
                console.log("Main Initializer: Scroll arrow setup complete.");
            } catch (error) {
                console.error("Main Initializer: Error setting up scroll arrows:", error);
            }

            // 2. Attach Delegated Item Launch Listener (Adjusted for "Apps")
            // This single listener on the main container handles clicks for *all* buttons
            // (both original in the main grid and cloned in the favorites section).
            try {
                const mainContainer = document.querySelector('main.hub-container');
                if (mainContainer) {
                    console.log("Main Initializer: Attaching delegated item launch listener to main.hub-container");
                    mainContainer.addEventListener('click', function(event) {
                        // Find the closest ancestor element that is a button with class 'btn' and has a data-path
                        const clickedButton = event.target.closest('.btn[data-path]');
                        if (!clickedButton) {
                            // console.log("Delegated listener: Clicked element is not a button with data-path."); // Debug non-button clicks
                            return; // Clicked outside an item button
                        }

                        // Check if the click originated from the heart icon *within* the button
                        // This prevents launching the app when trying to favorite/unfavorite
                        // We check for the icon itself or any ancestor that is the icon (like its SVG content)
                        if (event.target.classList.contains('heart-icon') || event.target.closest('.heart-icon')) {
                           console.log("Delegated listener: Heart click detected, stopping app launch.");
                           // The handleHeartIconClick listener already called stopPropagation(),
                           // but this check adds another layer of safety in case stopPropagation fails or is missed.
                           return;
                        }

                        console.log("Delegated listener: Valid button click detected for launching:", clickedButton); // DEBUG

                        const path = clickedButton.getAttribute('data-path');
                        const itemName = getButtonName(clickedButton); // Use the robust helper function

                        // Check if the path is valid and not just a placeholder '#'
                        if (path && path !== '#') {
                          console.log(`LAUNCHING (Delegated): "${itemName}" from path: "${path}"`); // DEBUG
                          // Save details to localStorage so the game.html page knows what to load
                          localStorage.setItem("lastClickedUrl", path);
                          localStorage.setItem("lastClickedGame", itemName); // Storing app name in 'lastClickedGame' for now
                          // Navigate to the generic loader page
                          window.location.href = "game.html";
                        } else {
                          console.error("Delegated Launch Error: Button missing or has invalid data-path.", clickedButton);
                          alert("Error: Could not determine app details to launch.");
                        }
                    });
                    console.log("Main Initializer: Delegated item launch listener attached.");
                } else {
                     console.error("Main Initializer: Could not find main.hub-container for delegated listener.");
                }
            } catch (error) {
                 console.error("Main Initializer: Error attaching delegated item launch listener:", error);
            }


            // 3. Attach Search Listeners (Uses filterGames now)
            try {
                console.log("Main Initializer: Attaching search listeners...");
                const searchInput = document.getElementById('myInput');
                const searchIconBtn = document.querySelector('.search-icon-btn');

                if (searchInput && searchIconBtn) {
                     // Clicking the icon focuses the input and performs filter
                     searchIconBtn.addEventListener('click', () => {
                       searchInput.focus();
                       filterGames(); // Call the updated function
                     });

                     // Pressing Enter in the input performs filter
                     searchInput.addEventListener('keypress', function(event) {
                       if (event.key === 'Enter') {
                         event.preventDefault(); // Prevent form submission if input was in a form
                         filterGames(); // Call the updated function
                       }
                     });

                     // Debounce keyup/input for better performance as user types
                     searchInput.addEventListener('input', debounce(filterGames, 250)); // Use 'input' for clears etc.
                     console.log("Main Initializer: Search listeners attached.");
                 } else {
                    console.error("Main Initializer: Search input (#myInput) or button (.search-icon-btn) not found.");
                 }

                // 4. Initial Filter on Load (if search has a value from browser history/refresh)
                // Perform this check *after* favoriting script might have added/removed elements.
                if (searchInput && searchInput.value.trim() !== '') {
                  console.log("Main Initializer: Performing initial filter based on input value.");
                  filterGames(); // Call the updated function
                } else {
                   console.log("Main Initializer: No initial search value, skipping filter.");
                }
            } catch (error) {
                 console.error("Main Initializer: Error attaching search listeners or performing initial filter:", error);
            }

            console.log("Main Initializer: Initialization complete.");
        });
      </script>

      <!-- Particles.js Initialization (Self-contained in IIFE) -->
      <script>
      particlesJS("particles-js", {
            "particles": {
                "number": {
                    "value": 80,
                    "density": {
                        "enable": true,
                        "value_area": 800
                    }
                },
                "color": {
                    "value": "#ffffff"
                },
                "shape": {
                    "type": "circle",
                    "stroke": {
                        "width": 0,
                        "color": "#000000"
                    }
                },
                "opacity": {
                    "value": 0.5,
                    "random": true,
                    "anim": {
                        "enable": false,
                        "speed": 1,
                        "opacity_min": 0.1,
                        "sync": false
                    }
                },
                "size": {
                    "value": 3,
                    "random": true,
                    "anim": {
                        "enable": false,
                        "speed": 40,
                        "size_min": 0.1,
                        "sync": false
                    }
                },
                "line_linked": {
                    "enable": true,
                    "distance": 150,
                    "color": "#ffffff",
                    "opacity": 0.4,
                    "width": 1
                },
                "move": {
                    "enable": true,
                    "speed": 6,
                    "direction": "none",
                    "random": false,
                    "straight": false,
                    "out_mode": "out",
                    "bounce": false,
                    "attract": {
                        "enable": false,
                        "rotateX": 600,
                        "rotateY": 1200
                    }
                }
            },
            "interactivity": {
                "detect_on": "canvas",
                "events": {
                    "onhover": {
                        "enable": true,
                        "mode": "repulse"
                    },
                    "onclick": {
                        "enable": true,
                        "mode": "push"
                    },
                    "resize": true
                },
                "modes": {
                    "grab": {
                        "distance": 400,
                        "line_linked": {
                            "opacity": 1
                        }
                    },
                    "bubble": {
                        "distance": 400,
                        "size": 40,
                        "duration": 2,
                        "opacity": 8,
                        "speed": 3
                    },
                    "repulse": {
                        "distance": 200,
                        "duration": 0.4
                    },
                    "push": {
                        "particles_nb": 4
                    },
                    "remove": {
                        "particles_nb": 2
                    }
                }
            },
            "retina_detect": true
        });
        // console.log("Particles.js initialized successfully."); // DEBUG
      </script>

  </body>
  </html>